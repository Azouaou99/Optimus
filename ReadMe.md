Overview of SOFA-Verdandi integration plugin {#s:overview}
============================================

The goal of the plugin is to implement a real integration of Verdandi in
SOFA on order to provide a complex and efficient tool for
data-assimilation based on filtering prediction-correction scheme. In
particular, the main idea of the plugin is that:

-   the data assimilation (DA) is performed in the same way as a
    standard simulation in SOFA; therefore, in the following we use an
    abbreviation *SVDA* to denote a *SOFA-Verdandi Data assimilation*,
    by which we mean a data assimilation performed by SOFA (as the
    classical SOFA simulation) using Verdandi library.

-   Verdandi is used as a *data-assimilation engine* through the
    existing filters implemented in the library. The idea is to use the
    Verdandi code directly wihout the need of re-implementing the
    filters in SOFA but rather wrap them as SOFA components.

-   The *dynamics of the model* used in the prediction stage of the data
    assimilation is completely provided by SOFA using standard nodes and
    solvers.

-   The *observation manager* is also implemented in SOFA, relying in
    particular on the concept of SOFA mappings. Currently, the
    observation managers use data pre-generated by a *forward* SOFA
    simulation, however, can be easily replaced with more advanced
    algorithms (extraction of positions via tracking etc.).

State handling and animation loop
---------------------------------

Based on these ideas, there are following main implementation concepts
of the integration implemented by components in the next section:

-   Verdandi keeps and handles its own state denoted in the following as
    ***V-state***. The ***V-state*** is an *extended state* in Verdandi
    sense containing the vector of DoF-related quantities (position,
    velocity...) and the vector of model parameters being estimated.
    ***V-state*** is of verdandi type: `Seldon::vector`.

-   The Verdandi filter (such as reduced-order UKF or EKF, ROUKF, ROEKF)
    governs the evolution of the ***V-state***: in each step of *SVDA*,
    the ***V-state*** is modified through prediction phase (based on
    model dynamics) and correction phase (based on observation).

-   Currently it is supposed that there is only one filter per *SVDA* 
    therefore only one ***V-state*** exists, however, the number of
    physical objects (represented by SOFA nodes) is not limited.

Due to the character of the *SVDA* where the evolution of the system is
performed by the filter (through the prediction and correction phases),
an *SVDA* scene is governed by a custom `VerdandiAnimationLoop`. In
fact, the component only re-implements the `step` procedure and calls
the filter sub-routines `InitializeStep`, `Forward` (i. e. prediction),
`Analyze` (i. e. correction) and `FinalizeStep`.

Within SOFA, the filter itself is represented by a wrapper (such as
`SofaReducedOrderUKF`). Currently, the wrapper re-implements the
initialization procedures in order to avoid using LUA configurations as
it would not be practical to set use both XML and LUA for creating an
*SVDA*. Currently, the LUA is not used anymore for defining the
parameters of *SVDA*, which is completely given by the XML (or
python\...) scene. In the future, the `VerdandiAnimationLoop` component
might be removed completely and the step could be implemented directly
by the filter wrapper (this is not currently done due to compilation
issues).

Parameter handling
------------------

The main goal of the *SVDA* (and data assimilation in general) is to
estimate a set of model parameters based on the model dynamics and
observations, where both are associated with uncertainties.

From the SOFA point of view, the parameters are usually simple numbers
(or vectors of numbers) handled by local components: for example, the
Young's modulus is a number (usually constant) defined and handled by
the FEM-component, stiffnesses of a set of springs is a vector handled
by the spring component.

From the Verdandi point of view, the parameters are included in the
extended state (***V-state*** in our case) and they evolve together with
the model state. The parameters are not regarded as simple numbers, but
as probability distributions (defined by corresponding statistics as
mean value and variance). Since the model itself requires concrete
instances the parameters, these are instantiated in each `Forward` step
using the method of $\sigma-$*point*.

In order to integrate the two different concepts, a new component was
introduced, namely `OptimParams`:

-   The component is a container of parameters which vary during the
    *SVDA*. The parameters are defined using *initial value* and
    *standard deviation*.

-   It also handles correct update of the ***V-state***: it works as an
    *interface* between SOFA and Verdandi in terms of parameters.

-   If option `optimize` is true (which is the case by default), **the
    node containing the component is considered as the part of the
    physical model assimilated by Verdandi**, being denoted as an
    ***assimilation node***. This is extremely important, since in turn
    it means that the mechanical state of this node will be associated
    with its counterpart included in the ***V-state***. If in a node
    this component is not present, or `optimize="0"`, the object modeled
    by the node is not included in the assimilation: currently, this
    functionality is mainly used for mapped objects (collision,
    visualisation etc.).

In each phase and step of the *SVDA*, the actual value of the parameters
handled by `OptimParams` can be accessed via SOFA `Data<> value`.
Therefore, the components which depends on the parameters being
optimized (such as already mentioned Young's modulus) must be linked via
@. **It must be verified, that the component which depends on the
parameters being optimized is compatible with the fact that this
parameter changes in each step,** i. e. there are no internal structures
which are precomputed using the initial values of the parameters.

The `OptimParams` component was conceived to be as general as possible,
therefore it can handle structures defined as `Data<DataTypes>` where
`DataTypes` is the parameter of template (which could be virtually any
type (scalars, vectors of scalars, *VecCoord* etc.). In order to achieve
this degree of generality, the concept of *functors* was employed as can
be seen in the code of the component.

Finally, in one node, several `OptimParams` can be present if different
types of parameters are to be optimized (this has been test only
partially...).

Prediction: `Forward`
---------------------

In the forward stage, the filter performs the prediction phase by
evaluating on *operator* (UKF) and/or it's derivatives (EKF). This
evaluation is done for each $\sigma-$*point* independently and the
result is used to compute the mean prediction (*a priori*) value of the
***V-state***. The *operator* $\mathcal{O}$ is in fact a time step of
the model, here represented by a standard SOFA simulation time step. A
few facts about $\mathcal{O}$ must be emphasized:

-   From the Verdandi point of view, it acts on the state provided by
    Verdandi (***V-state***), so for a given ***V-state*** $X_n$ it
    performs $X^-_{n+1} =
    \mathcal{O}(X_{n})$.

-   From the SOFA point of view, it performs a single step of the
    simulation on a given DoF positions/velocities (encoded as a part of
    $X_n$) while taking into account the current parameters (also
    encoded as a part of $X_n$).

-   It is evaluated several times in each step of *SVDA*, namely, it is
    evaluated for each $\sigma-$*point* which is a different
    perturbation of $X_{n+1}$ according to the chosen method (simplex,
    star, circle).

In order to facilitate the integration of SOFA and Verdandi, it was
desirable to make the real evaluation of $\mathcal{O}$ (SOFA model)
completely transparent from the Verdandi point of view. For this reason,
a new component `SofaModelWrapper` was created: it serves as a wrapper
of all ***assimilation nodes***and ensures the correspondence between
the respective mechanical states and parameters inside each
***assimilation node*** and the ***V-state***.

The component is not explicitly included in the scene but it is
instantiated dynamically during the initialization of the filter
wrapper. This might change in future; at this moment it is a workaround
for Verdandi which unfortunately instantiate the model in filter
initialization and uses reference (not a pointer) during the
assimilation. There is only one `SofaModelWrapper` in the entire *SVDA*,
however, it can handle multiple ***assimilation nodes*** which
constitute the actual physical model (e.g. one for a deformable body,
other for a needle).

This part is also the trickiest one in terms of the implementation as
the SOFA components are usually not implemented with the idea of total
independence on the previous (the highlighted part in the previous
section).

The forward stage is computationally expensive mainly due to multiple
evaluation of the model; the subsequent manipulation with
***V-state*** are rather cheap. At the same time, the execution of the
operator is embarrassingly parallel. However, the main issue is that for
a parallelization on $N$ threads, $N$ independent copies of the SOFA
world would have to be created (TODO, with python maybe? ).

Correction: `Analyze`
---------------------

While the forward stage requires a significant manipulation
***V-state*** and ***assimilation nodes***, analyze stage is almost
exclusively performed by Verdandi filter. The only part supplied by SOFA
is the `ObservationManager` which computes an *innovation* using
prediction computed previously and observations obtained by an external
source.

So far, we have been experimenting only with simple cases where the
observations are generated using a *forward simulation*, i. e. a
standard SOFA simulation where the states of the modeled objects are
stored in each step into a text file using SOFA monitors. Then, each
***assimilation node*** has to have an *observation sub-node* which
contains following components:

-   Mechanical object which defines a set of observation points. These
    can be any points inside the moving objects were observations are
    made (trivially, it can be equivalent to the mechanical state of the
    assimilated object).

-   Mapping between the observation mechanical state and the mechanical
    state of the assimilated body (trivially an `IdentityMapping`,
    usually a `BarycentricMapping`.

-   An observation manager which provides a method `GetInnovation`
    called by the Verdandi filter. The method must have an access to
    observation in each time (supplied for example by an
    `ObservationSource` and it uses mapping (`Apply`) to get the
    observations in points defined by the mechanical state.

So far we are using `SimulationStateObservationSource` in order to read
the positions exported by monitors in forward simulations. Currently,
the code allows for adding a noise, although only in very preliminary
version.

Components
==========

`VerdandiAnimationLoop`

-   Compliant with SOFA API for animation loops.

-   Calls filter wrapper to perform the assimilation in each step.

\medskip
{\large \sroukf}
-   Wrapper of Verdandi ReducedOrderUKF (inherits from ROUKF and
    BaseNode).

-   Templated on model and observation manager.

-   Basically replaces initialisation to avoid reading the parameters
    from LUA and uses parameters defined in XML scene instead.

\medskip
{\large\smw}
-   Wrapper of ***assimilation nodes*** in SOFA: looks for all
    ***assimilation nodes*** in the initialization via `OptimParams`.

-   Templated on scalar type (might change in future).

-   Created in filter initialization; probably OK (it's not a real
    object but somehow represents entire SOFA scene w. r. t. Verdandi.

-   The component is initialized via `initSimuData` called by
    `SofaReducedOrderUKF``.init()` receiving the parameters set to
    `SofaReducedOrderUKF` (as this component cannot receive any
    parameters from XML via `ModelData` structure.

\medskip
{\large\opr}
-   Container of parameters in given ***assimilation node***.

-   Templated on any numerical type in SOFA, specializations needed.

-   Abstract pure base `OptimParamsBase` created to facilitate the
    manipulation and define the API.

-   In *forward mode*, it can be used either as a simple container of
    parameters which remain constant, or as a *parameter controller*
    which can change the parameters during the simulation. The change is
    defined using option
    `prescribedParamKeys="T^0 v_0^0 ... v_n^0 T^1 v_0^1 ... v_n^1 ... ... T^t v^t_0 ... v^t_n"`
    where the values of parameters are defined in each time T$^t$ (not a
    time step, but the simulation time). Here, the option `numParams` is
    required in order to parse the keys correctly. The transition
    between two different values can be done smoothly (based on `tanh`),
    the option `interpolateSmooth`. Finally, the initial value in the
    XML file is ignored and only the keys are used so that the real
    value of the parameter is interpolated for given time step.

-   The value of parameteres in each time step can be exported using
    option `exportParamFile`.

-   In the *filtering mode*, only the initial value `initValue` together
    with the standard deviation `stdev` are set in the XML file.

-   In some optimization cases, it's desirable to keep some properties
    of the parameters being optimized (e.g positivity for the Young's
    modulus. The option `transformParams` can be used to choose between:
    0 (the no transformation is done) 1: absolute value of the
    parameters is taken before feeding the model.

\medskip
{\large\mobs}
-   Observation manager computing the innovation based on current
    prediction and observation.

-   Templated on `DataTypes1` and `DataTypes2` since it calls mapping
    apply (having also two template parameters).

-   Inherits from `SofaLinearObservationManager` which is only an
    abstract base (inheriting from Verdandi observation manager).

-   The uncertainty of the observations from Verdandi point of view is
    set using option `observationStdev` which is the standard deviation
    of observations assumed in the data assimilation.

-   Noise can be added using `noiseStdev`: the noise is generated using
    `Boost`, has a normal distribution with zero mean and standard
    deviation given by `noiseStdev`.

\medskip
{\large\texttt{SimulatedStateObservationSource}}
-   Auxiliary components that reads and provides observations stored in
    a monitor file generated by a forward simulation.

-   Mainly supplies `GetObservation` method called by the observation
    manager.

-   Requires correct prefix of the monitor-generated file.

Compilation and Usage
=====================

The plugin is stored in OptimusPlugin repository at GForge. In order to
compile the plugin with verdandi, it is necessary to:

-   Make the svn check-out of the plugin to `applications-dev/plugins`.

-   Create the symbolic link to verdandi code in extlibs:
    `cd $SOFA_DIR/extlibs; ln -s ../applications-dev/plugins/Optimus/verdandiSofa/verdandi-1.5`

-   Check `SOFA_EXTERNAL_VERDANDI` and `SOFA_DEVPLUGIN_OPTIMUS` in
    cmake-gui

-   Compile.

In the plugin, Verdandi version 1.5 is used. Several fixes had to be
made in the code in order to compile with SOFA on Linux/Mac (should be
somehow "systematised" maybe with the guys from Verdandi development.

Even after fixing the problems, the compilation was still tricky: the
consequence is that all the classes that inherit from Verdandi have to
be in the same file (SofaModelWrapper.h, inl and cpp), which is quite
inconvenient but I did not find a better solution (apart from rewriting
the filter from Verdandi to SOFA, which would be finally much easier).

Actually, the compilation is tested only under Linux. GCC version 4.8 is
required and to run the *SVDA* properly, `Pardiso` solver is required;
it's driver is currently under Bilikimo project repository.
